{"ast":null,"code":"/*!\n * minirefresh v2.0.2\n * (c) 2017-2018 dailc\n * Released under the MIT License.\n * https://github.com/minirefresh/minirefresh\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.MiniRefreshTools = factory();\n})(this, function () {\n  'use strict';\n\n  function getNow() {\n    return window.performance && (window.performance.now ? window.performance.now() + window.performance.timing.navigationStart : +new Date());\n  }\n\n  var noop = function noop() {};\n\n  function isArray(object) {\n    if (Array.isArray) {\n      return Array.isArray(object);\n    }\n\n    return object instanceof Array;\n  }\n\n  function isObject(object) {\n    var classType = Object.prototype.toString.call(object).match(/^\\[object\\s(.*)\\]$/)[1];\n    return classType !== 'String' && classType !== 'Number' && classType !== 'Boolean' && classType !== 'Undefined' && classType !== 'Null';\n  }\n\n  function isWindow(object) {\n    return object && object === window;\n  }\n\n  function isPlainObject(obj) {\n    return isObject(obj) && !isWindow(obj) // 如果不是普通的object,Object.prototype需要通过链回溯才能得到\n    && Object.getPrototypeOf(obj) === Object.prototype;\n  }\n\n  function extend() {\n    var _arguments = arguments;\n    var len = arguments.length;\n    var target = (arguments.length <= 0 ? undefined : arguments[0]) || {};\n    var sourceIndex = 1;\n    var isDeep = false;\n\n    if (typeof target === 'boolean') {\n      // 深赋值或false\n      isDeep = target;\n      target = (arguments.length <= sourceIndex ? undefined : arguments[sourceIndex]) || {};\n      sourceIndex++;\n    }\n\n    if (!isObject(target)) {\n      // 确保拓展的一定是object\n      target = {};\n    }\n\n    var _loop = function _loop() {\n      // source的拓展\n      var source = _arguments.length <= sourceIndex ? undefined : _arguments[sourceIndex];\n\n      if (source && isObject(source)) {\n        // for-of打包过大\n        Object.keys(source).forEach(function (name) {\n          var src = target[name];\n          var copy = source[name];\n          var copyIsPlainObject = isPlainObject(copy);\n          var copyIsArray = isArray(copy);\n          var clone = void 0;\n\n          if (target === copy) {\n            // 防止环形引用\n            return;\n          }\n\n          if (isDeep && copy && (copyIsArray || copyIsPlainObject)) {\n            // 这里必须用isPlainObject,只有同样是普通的object才会复制继承\n            // 如果是FormData之流的，会走后面的覆盖路线\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && isArray(src) ? src : [];\n            } else {\n              clone = src && isPlainObject(src) ? src : {};\n            }\n\n            target[name] = extend(isDeep, clone, copy);\n          } else if (copy !== undefined) {\n            // 如果非深赋值\n            // 或者不是普通的object，直接覆盖，例如FormData之类的也会覆盖\n            target[name] = copy;\n          }\n        });\n      }\n    };\n\n    for (; sourceIndex < len; sourceIndex++) {\n      _loop();\n    }\n\n    return target;\n  }\n  /**\n   * 选择这段代码用到的太多了，因此抽取封装出来\n   * @param {Object} element dom元素或者selector\n   * @return {HTMLElement} 返回选择的Dom对象，无果没有符合要求的，则返回null\n   */\n\n\n  function selector(element) {\n    var target = element;\n\n    if (typeof target === 'string') {\n      target = document.querySelector(target);\n    }\n\n    return target;\n  }\n  /**\n   * 获取DOM的可视区高度，兼容PC上的body高度获取\n   * 因为在通过body获取时，在PC上会有CSS1Compat形式，所以需要兼容\n   * @param {HTMLElement} dom 需要获取可视区高度的dom,对body对象有特殊的兼容方案\n   * @return {Number} 返回最终的高度\n   */\n\n\n  function getClientHeightByDom(dom) {\n    var height = dom.clientHeight;\n\n    if (dom === document.body && document.compatMode === 'CSS1Compat') {\n      // PC上body的可视区的特殊处理\n      height = document.documentElement.clientHeight;\n    }\n\n    return height;\n  }\n  /**\n   * 设置一个Util对象下的命名空间\n   * @param {Object} parent 需要绑定到哪一个对象上\n   * @param {String} namespace 需要绑定的命名空间名\n   * @param {Object} target 需要绑定的目标对象\n   * @return {Object} 返回最终的对象\n   */\n\n\n  function namespace(parent, namespaceStr, target) {\n    if (!namespaceStr) {\n      return parent;\n    }\n\n    var namespaceArr = namespaceStr.split('.');\n    var len = namespaceArr.length;\n    var res = parent;\n\n    for (var i = 0; i < len - 1; i += 1) {\n      var tmp = namespaceArr[i]; // 不存在的话要重新创建对象\n\n      res[tmp] = res[tmp] || {}; // parent要向下一级\n\n      res = res[tmp];\n    }\n\n    res[namespaceArr[len - 1]] = target;\n    return target;\n  }\n\n  var lang = Object.freeze({\n    getNow: getNow,\n    noop: noop,\n    isArray: isArray,\n    isObject: isObject,\n    isWindow: isWindow,\n    isPlainObject: isPlainObject,\n    extend: extend,\n    selector: selector,\n    getClientHeightByDom: getClientHeightByDom,\n    namespace: namespace\n  });\n  /**\n   * 加入系统判断功能\n   */\n\n  function osMixin(hybrid) {\n    var hybridJs = hybrid;\n\n    var detect = function detect(ua) {\n      this.os = {};\n      var android = ua.match(/(Android);?[\\s/]+([\\d.]+)?/);\n\n      if (android) {\n        this.os.android = true;\n        this.os.version = android[2];\n        this.os.isBadAndroid = !/Chrome\\/\\d/.test(window.navigator.appVersion);\n      }\n\n      var iphone = ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\n      if (iphone) {\n        this.os.ios = true;\n        this.os.iphone = true;\n        this.os.version = iphone[2].replace(/_/g, '.');\n      }\n\n      var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\n      if (ipad) {\n        this.os.ios = true;\n        this.os.ipad = true;\n        this.os.version = ipad[2].replace(/_/g, '.');\n      } // quickhybrid的容器\n\n\n      var quick = ua.match(/QuickHybrid/i);\n\n      if (quick) {\n        this.os.quick = true;\n      } // epoint的容器\n\n\n      var ejs = ua.match(/EpointEJS/i);\n\n      if (ejs) {\n        this.os.ejs = true;\n      }\n\n      var dd = ua.match(/DingTalk/i);\n\n      if (dd) {\n        this.os.dd = true;\n      } // 如果ejs和钉钉以及quick都不是，则默认为h5\n\n\n      if (!ejs && !dd && !quick) {\n        this.os.h5 = true;\n      }\n    };\n\n    detect.call(hybridJs, navigator.userAgent);\n  }\n\n  var DEFAULT_INTERVAL = 1000 / 60; // 立即执行\n\n  var requestAnimationFrame = function () {\n    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame // if all else fails, use setTimeout\n    || function requestAnimationFrameTimeOut(callback) {\n      // make interval as precise as possible.\n      return window.setTimeout(callback, (callback.interval || DEFAULT_INTERVAL) / 2);\n    };\n  }();\n\n  var _createClass$1 = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _classCallCheck$1(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n  /**\n   * 一些事件\n   */\n\n\n  var EVENT_INIT = 'initScroll';\n  var EVENT_SCROLL = 'scroll';\n  var EVENT_PULL = 'pull';\n  var EVENT_UP_LOADING = 'upLoading';\n  var EVENT_RESET_UP_LOADING = 'resetUpLoading';\n  var EVENT_DOWN_LOADING = 'downLoading';\n  var EVENT_CANCEL_LOADING = 'cancelLoading';\n  /**\n   * 一些hook\n   * hook是指挥它会影响逻辑\n   */\n\n  var HOOK_BEFORE_DOWN_LOADING = 'beforeDownLoading';\n  var PER_SECOND = 1000 / 60;\n  /**\n   * 滑动操作相关类\n   * 把一些滑动滚动逻辑单独剥离出来\n   * 确保Core中只有纯粹的API定义\n   */\n\n  var Scroll = function () {\n    /**\n     * 传入minirefresh对象，因为内部一些配置项依赖于minirefresh\n     * @param {Object} options 配置信息\n     * @constructor\n     */\n    function Scroll(minirefresh) {\n      _classCallCheck$1(this, Scroll);\n\n      this.contentWrap = minirefresh.contentWrap;\n      this.scrollWrap = minirefresh.scrollWrap;\n      this.options = minirefresh.options;\n      this.os = minirefresh.os; // 默认没有事件，需要主动绑定\n\n      this.events = {}; // 默认没有hook\n\n      this.hooks = {}; // 使用了scrollto后加锁，防止重复\n\n      this.isScrollTo = false; // 上拉和下拉的状态\n\n      this.upLoading = false;\n      this.downLoading = false; // 默认up是没有finish的\n\n      this.isFinishUp = false;\n\n      this._init();\n    }\n\n    _createClass$1(Scroll, [{\n      key: '_init',\n      value: function _init() {\n        var _this = this;\n\n        this._initPullDown();\n\n        this._initPullUp();\n\n        setTimeout(function () {\n          if (_this.options.down && _this.options.down.isAuto && !_this.options.down.isLock) {\n            // 满足自动下拉,需要判断是否需要动画（仅仅是首次）\n            if (_this.options.down.isAllowAutoLoading) {\n              _this.triggerDownLoading();\n            } else {\n              _this.events[EVENT_DOWN_LOADING] && _this.events[EVENT_DOWN_LOADING](true);\n            }\n          } else if (_this.options.up && _this.options.up.isAuto && !_this.options.up.isLock) {\n            // 满足上拉，上拉的配置由配置项决定（每一次）\n            _this.triggerUpLoading();\n          }\n\n          _this.events[EVENT_INIT] && _this.events[EVENT_INIT]();\n        });\n      }\n    }, {\n      key: 'refreshOptions',\n      value: function refreshOptions(options) {\n        this.options = options;\n      }\n      /**\n       * ContentWrap的translate动画，用于下拉刷新时进行transform动画\n       * @param {Number} y 移动的高度\n       * @param {Number} duration 过渡时间\n       */\n\n    }, {\n      key: 'translateContentWrap',\n      value: function translateContentWrap(y, duration) {\n        var translateY = y || 0;\n        var translateDuration = duration || 0; // 改变downHight， 这个参数关乎逻辑\n\n        this.downHight = translateY;\n\n        if (!this.options.down.isScrollCssTranslate) {\n          // 只有允许动画时才会scroll也translate,否则只会改变downHeight\n          return;\n        } // 改变wrap的位置（css动画）\n\n\n        var wrap = this.contentWrap;\n        wrap.style.webkitTransitionDuration = translateDuration + 'ms';\n        wrap.style.transitionDuration = translateDuration + 'ms';\n        wrap.style.webkitTransform = 'translate(0px, ' + translateY + 'px) translateZ(0px)';\n        wrap.style.transform = 'translate(0px, ' + translateY + 'px) translateZ(0px)';\n      }\n    }, {\n      key: '_scrollWrapAnimation',\n      value: function _scrollWrapAnimation() {\n        this.scrollWrap.webkitTransitionTimingFunction = 'cubic-bezier(0.1, 0.57, 0.1, 1)';\n        this.scrollWrap.transitionTimingFunction = 'cubic-bezier(0.1, 0.57, 0.1, 1)';\n      }\n    }, {\n      key: '_initPullDown',\n      value: function _initPullDown() {\n        var _this2 = this; // 考虑到options可以更新，所以不能被缓存，而是应该在回调中直接获取\n\n\n        var scrollWrap = this.scrollWrap;\n        var docClientHeight = document.documentElement.clientHeight;\n\n        this._scrollWrapAnimation(); // 触摸开始\n\n\n        var touchstartEvent = function touchstartEvent(e) {\n          if (_this2.isScrollTo) {\n            // 如果执行滑动事件,则阻止touch事件,优先执行scrollTo方法\n            e.preventDefault();\n          } // 记录startTop, 并且只有startTop存在值时才允许move\n\n\n          _this2.startTop = scrollWrap.scrollTop; // startY用来计算距离\n\n          _this2.startY = e.touches ? e.touches[0].pageY : e.clientY; // X的作用是用来计算方向，如果是横向，则不进行动画处理，避免误操作\n\n          _this2.startX = e.touches ? e.touches[0].pageX : e.clientX;\n        };\n\n        scrollWrap.addEventListener('touchstart', touchstartEvent);\n        scrollWrap.addEventListener('mousedown', touchstartEvent); // 触摸结束\n\n        var touchendEvent = function touchendEvent() {\n          var options = _this2.options; // 需要重置状态\n\n          if (_this2.isMoveDown) {\n            // 如果下拉区域已经执行动画,则需重置回来\n            if (_this2.downHight >= options.down.offset) {\n              // 符合触发刷新的条件\n              _this2.triggerDownLoading();\n            } else {\n              // 否则默认重置位置\n              _this2.translateContentWrap(0, options.down.bounceTime);\n\n              _this2.events[EVENT_CANCEL_LOADING] && _this2.events[EVENT_CANCEL_LOADING]();\n            }\n\n            _this2.isMoveDown = false;\n          }\n\n          _this2.startY = 0;\n          _this2.startX = 0;\n          _this2.preY = 0;\n          _this2.startTop = undefined; // 当前是否正处于回弹中，常用于iOS中判断，如果先上拉再下拉就处于回弹中（只要moveY为负）\n\n          _this2.isBounce = false;\n        };\n\n        scrollWrap.addEventListener('touchend', touchendEvent);\n        scrollWrap.addEventListener('mouseup', touchendEvent);\n        scrollWrap.addEventListener('mouseleave', touchendEvent); // 触摸中\n\n        var touchmoveEvent = function touchmoveEvent(e) {\n          var options = _this2.options;\n          var isAllowDownloading = true;\n\n          if (_this2.downLoading) {\n            isAllowDownloading = false;\n          } else if (!options.down.isAways && _this2.upLoading) {\n            isAllowDownloading = false;\n          }\n\n          if (_this2.startTop !== undefined && _this2.startTop <= 0 && isAllowDownloading && !_this2.options.down.isLock) {\n            // 列表在顶部且不在加载中，并且没有锁住下拉动画\n            // 当前第一个手指距离列表顶部的距离\n            var curY = e.touches ? e.touches[0].pageY : e.clientY;\n            var curX = e.touches ? e.touches[0].pageX : e.clientX; // 手指滑出屏幕触发刷新\n\n            if (curY > docClientHeight) {\n              touchendEvent(e);\n              return;\n            }\n\n            if (!_this2.preY) {\n              // 设置上次移动的距离，作用是用来计算滑动方向\n              _this2.preY = curY;\n            } // 和上次比,移动的距离 (大于0向下,小于0向上)\n\n\n            var diff = curY - _this2.preY;\n            _this2.preY = curY; // 和起点比,移动的距离,大于0向下拉\n\n            var moveY = curY - _this2.startY;\n            var moveX = curX - _this2.startX; // 如果锁定横向滑动并且横向滑动更多，阻止默认事件\n\n            if (options.isLockX && Math.abs(moveX) > Math.abs(moveY)) {\n              e.preventDefault();\n              return;\n            }\n\n            if (_this2.isBounce && _this2.os.ios) {\n              // 暂时iOS中去回弹\n              // 下一个版本中，分开成两种情况，一种是absolute的固定动画，一种是在scrollWrap内部跟随滚动的动画\n              return;\n            }\n\n            if (moveY > 0) {\n              // 向下拉\n              _this2.isMoveDown = true; // 阻止浏览器的默认滚动事件，因为这时候只需要执行动画即可\n\n              e.preventDefault();\n\n              if (!_this2.downHight) {\n                // 下拉区域的高度，用translate动画\n                _this2.downHight = 0;\n              }\n\n              var downOffset = options.down.offset;\n              var dampRate = 1;\n\n              if (_this2.downHight < downOffset) {\n                // 下拉距离  < 指定距离\n                dampRate = options.down.dampRateBegin;\n              } else {\n                // 超出了指定距离，随时可以刷新\n                dampRate = options.down.dampRate;\n              }\n\n              if (diff > 0) {\n                // 需要加上阻尼系数\n                _this2.downHight += diff * dampRate;\n              } else {\n                // 向上收回高度,则向上滑多少收多少高度\n                _this2.downHight += diff;\n              }\n\n              _this2.events[EVENT_PULL] && _this2.events[EVENT_PULL](_this2.downHight, downOffset); // 执行动画\n\n              _this2.translateContentWrap(_this2.downHight);\n            } else {\n              _this2.isBounce = true; // 解决嵌套问题。在嵌套有 IScroll，或类似的组件时，这段代码会生效，可以辅助滚动scrolltop\n              // 否则有可能在最开始滚不动\n\n              if (scrollWrap.scrollTop <= 0) {\n                scrollWrap.scrollTop += Math.abs(diff);\n              }\n            }\n          }\n        };\n\n        scrollWrap.addEventListener('touchmove', touchmoveEvent);\n        scrollWrap.addEventListener('mousemove', touchmoveEvent);\n      }\n    }, {\n      key: '_initPullUp',\n      value: function _initPullUp() {\n        var _this3 = this;\n\n        var scrollWrap = this.scrollWrap; // 如果是Body上的滑动，需要监听window的scroll\n\n        var targetScrollDom = scrollWrap === document.body ? window : scrollWrap;\n        targetScrollDom.addEventListener('scroll', function () {\n          var scrollTop = scrollWrap.scrollTop;\n          var scrollHeight = scrollWrap.scrollHeight;\n          var clientHeight = getClientHeightByDom(scrollWrap);\n          var options = _this3.options;\n          _this3.events[EVENT_SCROLL] && _this3.events[EVENT_SCROLL](scrollTop);\n          var isAllowUploading = true;\n\n          if (_this3.upLoading) {\n            isAllowUploading = false;\n          } else if (!options.down.isAways && _this3.downLoading) {\n            isAllowUploading = false;\n          }\n\n          if (isAllowUploading) {\n            if (!_this3.options.up.isLock && !_this3.isFinishUp && scrollHeight > 0) {\n              var toBottom = scrollHeight - clientHeight - scrollTop;\n\n              if (toBottom <= options.up.offset) {\n                // 满足上拉加载\n                _this3.triggerUpLoading();\n              }\n            }\n          }\n        });\n      }\n    }, {\n      key: '_loadFull',\n      value: function _loadFull() {\n        var _this4 = this;\n\n        var scrollWrap = this.scrollWrap;\n        var options = this.options;\n        setTimeout(function () {\n          // 在下一个循环中运行\n          if (!_this4.options.up.isLock && options.up.loadFull.isEnable // 避免无法计算高度时无限加载\n          && scrollWrap.scrollTop === 0 // scrollHeight是网页内容高度（最小值是clientHeight）\n          && scrollWrap.scrollHeight > 0 && scrollWrap.scrollHeight <= getClientHeightByDom(scrollWrap)) {\n            _this4.triggerUpLoading();\n          }\n        }, options.up.loadFull.delay || 0);\n      }\n    }, {\n      key: 'triggerDownLoading',\n      value: function triggerDownLoading() {\n        var options = this.options;\n\n        if (!this.hooks[HOOK_BEFORE_DOWN_LOADING] || this.hooks[HOOK_BEFORE_DOWN_LOADING](this.downHight, options.down.offset)) {\n          // 没有hook或者hook返回true都通过，主要是为了方便类似于秘密花园等的自定义下拉刷新动画实现\n          this.downLoading = true;\n          this.translateContentWrap(options.down.offset, options.down.bounceTime);\n          this.events[EVENT_DOWN_LOADING] && this.events[EVENT_DOWN_LOADING]();\n        }\n      }\n    }, {\n      key: 'endDownLoading',\n      value: function endDownLoading() {\n        var options = this.options;\n\n        if (this.downLoading) {\n          // 必须是loading时才允许结束\n          this.translateContentWrap(0, options.down.bounceTime);\n          this.downLoading = false;\n        }\n      }\n    }, {\n      key: 'triggerUpLoading',\n      value: function triggerUpLoading() {\n        this.upLoading = true;\n        this.events[EVENT_UP_LOADING] && this.events[EVENT_UP_LOADING]();\n      }\n      /**\n       * 结束上拉加载动画时需要判断是否已经finished(不能加载更多，没有数据了)\n       * @param {Boolean} isFinishUp 是否结束上拉加载\n       */\n\n    }, {\n      key: 'endUpLoading',\n      value: function endUpLoading(isFinishUp) {\n        if (this.upLoading) {\n          this.upLoading = false;\n\n          if (isFinishUp) {\n            this.isFinishUp = true;\n          } else {\n            this._loadFull();\n          }\n        }\n      }\n    }, {\n      key: 'resetUpLoading',\n      value: function resetUpLoading() {\n        if (this.isFinishUp) {\n          this.isFinishUp = false;\n        } // 检测是否需要加载满屏\n\n\n        this._loadFull();\n\n        this.events[EVENT_RESET_UP_LOADING] && this.events[EVENT_RESET_UP_LOADING]();\n      }\n      /**\n       * 滚动到指定的y位置\n       * @param {Number} y top坐标\n       * @param {Number} duration 单位毫秒\n       */\n\n    }, {\n      key: 'scrollTo',\n      value: function scrollTo(y, duration) {\n        var _this5 = this;\n\n        var scrollWrap = this.scrollWrap;\n        var translateDuration = duration || 0; // 最大可滚动的y\n\n        var maxY = scrollWrap.scrollHeight - getClientHeightByDom(scrollWrap);\n        var translateY = y || 0;\n        translateY = Math.max(translateY, 0);\n        translateY = Math.min(translateY, maxY); // 差值 (可能为负)\n\n        var diff = scrollWrap.scrollTop - translateY;\n\n        if (diff === 0 || translateDuration === 0) {\n          scrollWrap.scrollTop = translateY;\n          return;\n        } // 每秒60帧，计算一共多少帧，然后每帧的步长\n\n\n        var count = Math.floor(translateDuration / PER_SECOND);\n        var step = diff / count;\n        var curr = 0;\n\n        var execute = function execute() {\n          if (curr < count) {\n            if (curr === count - 1) {\n              // 最后一次直接设置y,避免计算误差\n              scrollWrap.scrollTop = translateY;\n            } else {\n              scrollWrap.scrollTop -= step;\n            }\n\n            curr += 1;\n            requestAnimationFrame(execute);\n          } else {\n            scrollWrap.scrollTop = translateY;\n            _this5.isScrollTo = false;\n          }\n        }; // 锁定状态\n\n\n        this.isScrollTo = true;\n        requestAnimationFrame(execute);\n      }\n      /**\n       * 监听事件，包括下拉过程，下拉刷新，上拉加载，滑动等事件都可以监听到\n       * @param {String} event 事件名，可选名称\n       * 在最上方的常量有定义\n       * @param {Function} callback 回调函数\n       */\n\n    }, {\n      key: 'on',\n      value: function on(event, callback) {\n        if (event && typeof callback === 'function') {\n          this.events[event] = callback;\n        }\n      }\n      /**\n       * 注册钩子函数，主要是一些自定义刷新动画时用到，如进入秘密花园\n       * @param {String} hook 名称，范围如下\n       * beforeDownLoading 是否准备downLoading，如果返回false，则不会loading，完全进入自定义动画\n       * @param {Function} callback 回调函数\n       */\n\n    }, {\n      key: 'hook',\n      value: function hook(_hook, callback) {\n        if (_hook && typeof callback === 'function') {\n          this.hooks[_hook] = callback;\n        }\n      }\n    }]);\n\n    return Scroll;\n  }();\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var defaultSetting = {\n    // 下拉有关\n    down: {\n      // 默认没有锁定，可以通过API动态设置\n      isLock: false,\n      // 是否自动下拉刷新\n      isAuto: false,\n      // 设置isAuto=true时生效，是否在初始化的下拉刷新触发事件中显示动画，如果是false，初始化的加载只会触发回调，不会触发动画\n      isAllowAutoLoading: true,\n      // 是否不管任何情况下都能触发下拉刷新，为false的话当上拉时不会触发下拉\n      isAways: false,\n      // 是否scroll在下拉时会进行移动(css3)，通过关闭它可以实现自定义动画\n      isScrollCssTranslate: true,\n      // 是否每次下拉完毕后默认重置上拉\n      isAutoResetUpLoading: true,\n      // 下拉要大于多少长度后再下拉刷新\n      offset: 75,\n      // 阻尼系数，下拉小于offset时的阻尼系数，值越接近0,高度变化越小,表现为越往下越难拉\n      dampRateBegin: 1,\n      // 阻尼系数，下拉的距离大于offset时,改变下拉区域高度比例;值越接近0,高度变化越小,表现为越往下越难拉\n      dampRate: 0.3,\n      // 回弹动画时间\n      bounceTime: 300,\n      successAnim: {\n        // 下拉刷新结束后是否有成功动画，默认为false，如果想要有成功刷新xxx条数据这种操作，请设为true，并实现对应hook函数\n        isEnable: false,\n        duration: 300\n      },\n      // 下拉时会提供回调，默认为null不会执行\n      onPull: null,\n      // 取消时回调\n      onCalcel: null,\n      callback: noop\n    },\n    // 上拉有关\n    up: {\n      // 默认没有锁定，可以通过API动态设置\n      isLock: false,\n      // 是否自动上拉加载-初始化是是否自动\n      isAuto: true,\n      // 是否默认显示上拉进度条，可以通过API改变\n      isShowUpLoading: true,\n      // 距离底部高度(到达该高度即触发)\n      offset: 100,\n      loadFull: {\n        // 开启配置后，只要没满屏幕，就会自动加载\n        isEnable: true,\n        delay: 300\n      },\n      // 滚动时会提供回调，默认为null不会执行\n      onScroll: null,\n      callback: noop\n    },\n    // 容器\n    container: '#minirefresh',\n    // 是否锁定横向滑动，如果锁定则原生滚动条无法滑动\n    isLockX: true,\n    // 是否显示滚动条\n    isScrollBar: true,\n    // 是否使用body对象的scroll而不是minirefresh-scroll对象的scroll\n    // 开启后一个页面只能有一个下拉刷新，否则会有冲突\n    isUseBodyScroll: false\n  };\n  var CLASS_HIDDEN_SCROLLBAR = 'minirefresh-hide-scrollbar';\n\n  var Core = function () {\n    /**\n     * 构造函数\n     * @param {Object} options 配置信息\n     * @constructor\n     */\n    function Core(options) {\n      _classCallCheck(this, Core);\n\n      osMixin(this);\n      this.options = extend(true, {}, defaultSetting, options);\n      this.container = selector(this.options.container); // scroll的dom-wrapper下的第一个节点，作用是down动画时的操作\n\n      this.contentWrap = this.container.children[0]; // 默认是整个container进行滚动\n      // 但是为了兼容body的滚动，拆分为两个对象方便处理\n      // 如果是使用body的情况，scrollWrap恒为body\n      // 注意，滑动不是指下拉时的translate（这时候时contentWrap），而是只默认的原生滑动\n\n      this.scrollWrap = this.options.isUseBodyScroll ? document.body : this.container;\n\n      if (!this.options.isScrollBar) {\n        this.container.classList.add(CLASS_HIDDEN_SCROLLBAR);\n      } // 初始化的hook\n\n\n      this._initHook && this._initHook(this.options.down.isLock, this.options.up.isLock); // 生成一个Scroll对象 ，对象内部处理滑动监听\n\n      this.scroller = new Scroll(this); // 内部处理scroll\n\n      this._initEvent(); // 如果初始化时锁定了，需要触发锁定，避免没有锁定时解锁（会触发逻辑bug）\n\n\n      this.options.up.isLock && this._lockUpLoading(this.options.up.isLock);\n      this.options.down.isLock && this._lockDownLoading(this.options.down.isLock);\n    }\n\n    _createClass(Core, [{\n      key: '_initEvent',\n      value: function _initEvent() {\n        var _this = this; // 缓存options，这部分的配置是不允许reset的\n\n\n        var options = this.options;\n        this.scroller.on('initScroll', function () {\n          _this._initScrollHook && _this._initScrollHook();\n        });\n        this.scroller.on('downLoading', function (isHideLoading) {\n          !isHideLoading && _this._downLoaingHook && _this._downLoaingHook();\n          options.down.callback && options.down.callback();\n        });\n        this.scroller.on('cancelLoading', function () {\n          _this._cancelLoaingHook && _this._cancelLoaingHook();\n          options.down.onCalcel && options.down.onCalcel();\n        });\n        this.scroller.on('pull', function (downHight, downOffset) {\n          _this._pullHook && _this._pullHook(downHight, downOffset);\n          options.down.onPull && options.down.onPull(downHight, downOffset);\n        });\n        this.scroller.on('upLoading', function () {\n          _this._upLoaingHook && _this._upLoaingHook(_this.options.up.isShowUpLoading);\n          options.up.callback && options.up.callback(_this.options.up.isShowUpLoading);\n        });\n        this.scroller.on('resetUpLoading', function () {\n          _this._resetUpLoadingHook && _this._resetUpLoadingHook();\n        });\n        this.scroller.on('scroll', function (scrollTop) {\n          _this._scrollHook && _this._scrollHook(scrollTop);\n          options.up.onScroll && options.up.onScroll(scrollTop);\n        }); // 检查是否允许普通的加载中，如果返回false，就代表自定义下拉刷新，通常自己处理\n\n        this.scroller.hook('beforeDownLoading', function (downHight, downOffset) {\n          return !_this._beforeDownLoadingHook || _this._beforeDownLoadingHook(downHight, downOffset);\n        });\n      }\n      /**\n       * 内部执行，结束下拉刷新\n       * @param {Boolean} isSuccess 是否下拉请求成功\n       * @param {String} successTips 需要更新的成功提示\n       * 在开启了成功动画时，往往成功的提示是需要由外传入动态更新的，譬如  update 10 news\n       */\n\n    }, {\n      key: '_endDownLoading',\n      value: function _endDownLoading(isSuccess, successTips) {\n        var _this2 = this;\n\n        if (!this.options.down) {\n          // 防止没传down导致错误\n          return;\n        }\n\n        if (this.scroller.downLoading) {\n          // 必须是loading时才允许执行对应hook\n          var successAnim = this.options.down.successAnim.isEnable;\n          var successAnimTime = this.options.down.successAnim.duration;\n\n          if (successAnim) {\n            // 如果有成功动画\n            this._downLoaingSuccessHook && this._downLoaingSuccessHook(isSuccess, successTips);\n          } else {\n            // 默认为没有成功动画\n            successAnimTime = 0;\n          }\n\n          setTimeout(function () {\n            // 成功动画结束后就可以重置位置了\n            _this2.scroller.endDownLoading(); // 触发结束hook\n\n\n            _this2._downLoaingEndHook && _this2._downLoaingEndHook(isSuccess);\n          }, successAnimTime);\n        }\n      }\n      /**\n       * 锁定上拉加载\n       * 将开启和禁止合并成一个锁定API\n       * @param {Boolean} isLock 是否锁定\n       */\n\n    }, {\n      key: '_lockUpLoading',\n      value: function _lockUpLoading(isLock) {\n        this.options.up.isLock = isLock;\n        this._lockUpLoadingHook && this._lockUpLoadingHook(isLock);\n      }\n      /**\n       * 锁定下拉刷新\n       * @param {Boolean} isLock 是否锁定\n       */\n\n    }, {\n      key: '_lockDownLoading',\n      value: function _lockDownLoading(isLock) {\n        this.options.down.isLock = isLock;\n        this._lockDownLoadingHook && this._lockDownLoadingHook(isLock);\n      }\n      /**\n       * 刷新minirefresh的配置，关键性的配置请不要更新，如容器，回调等\n       * @param {Object} options 新的配置，会覆盖原有的\n       */\n\n    }, {\n      key: 'refreshOptions',\n      value: function refreshOptions(options) {\n        this.options = extend(true, {}, this.options, options);\n        this.scroller.refreshOptions(this.options);\n\n        this._lockUpLoading(this.options.up.isLock);\n\n        this._lockDownLoading(this.options.down.isLock);\n\n        this._refreshHook && this._refreshHook();\n      }\n      /**\n       * 结束下拉刷新\n       * @param {Boolean} isSuccess 是否请求成功，这个状态会中转给对应主题\n       * @param {String} successTips 需要更新的成功提示\n       * 在开启了成功动画时，往往成功的提示是需要由外传入动态更新的，譬如  update 10 news\n       */\n\n    }, {\n      key: 'endDownLoading',\n      value: function endDownLoading() {\n        var isSuccess = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var successTips = arguments[1];\n\n        this._endDownLoading(isSuccess, successTips); // 同时恢复上拉加载的状态，注意，此时没有传isShowUpLoading，所以这个值不会生效\n\n\n        if (this.options.down.isAutoResetUpLoading) {\n          this.resetUpLoading();\n        }\n      }\n      /**\n       * 重置上拉加载状态,如果是没有更多数据后重置，会变为可以继续上拉加载\n       */\n\n    }, {\n      key: 'resetUpLoading',\n      value: function resetUpLoading() {\n        this.scroller.resetUpLoading();\n      }\n      /**\n       * 结束上拉加载\n       * @param {Boolean} isFinishUp 是否结束上拉加载，如果结束，就相当于变为了没有更多数据，无法再出发上拉加载了\n       * 结束后必须reset才能重新开启\n       */\n\n    }, {\n      key: 'endUpLoading',\n      value: function endUpLoading(isFinishUp) {\n        if (this.scroller.upLoading) {\n          this.scroller.endUpLoading(isFinishUp);\n          this._upLoaingEndHook && this._upLoaingEndHook(isFinishUp);\n        }\n      }\n    }, {\n      key: 'triggerUpLoading',\n      value: function triggerUpLoading() {\n        this.scroller.triggerUpLoading();\n      }\n    }, {\n      key: 'triggerDownLoading',\n      value: function triggerDownLoading() {\n        this.scroller.scrollTo(0);\n        this.scroller.triggerDownLoading();\n      }\n      /**\n       * 滚动到指定的y位置\n       * @param {Number} y 需要滑动到的top值\n       * @param {Number} duration 单位毫秒\n       */\n\n    }, {\n      key: 'scrollTo',\n      value: function scrollTo(y, duration) {\n        this.scroller.scrollTo(y, duration);\n      }\n      /**\n       * 获取当前的滚动位置\n       * @return {Number} 返回当前的滚动位置\n       */\n\n    }, {\n      key: 'getPosition',\n      value: function getPosition() {\n        return this.scrollWrap.scrollTop;\n      }\n    }]);\n\n    return Core;\n  }();\n\n  var MiniRefreshTools$2 = {};\n  Object.keys(lang).forEach(function (name) {\n    MiniRefreshTools$2[name] = lang[name];\n  }); // namespace的特殊把绑定\n\n  MiniRefreshTools$2.namespace = function (namespaceStr, target) {\n    namespace(MiniRefreshTools$2, namespaceStr, target);\n  };\n\n  MiniRefreshTools$2.Core = Core;\n  MiniRefreshTools$2.version = '2.0.0'; // 防止主题和核心一起，并且require模式中，无法全局变量的情况\n\n  window.MiniRefreshTools = MiniRefreshTools$2;\n\n  var _createClass$2 = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _classCallCheck$2(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var Core$2 = MiniRefreshTools.Core;\n  var version = MiniRefreshTools.version;\n  var extend$1 = MiniRefreshTools.extend;\n  var namespace$1 = MiniRefreshTools.namespace;\n  /**\n   * 一些默认提供的CSS类，一般来说不会变动（由框架提供的）\n   * THEME 字段会根据不同的主题有不同值\n   * 在使用body的scroll时，需要加上样式 CLASS_BODY_SCROLL_WRAP\n   */\n\n  var CLASS_THEME = 'minirefresh-theme-default';\n  var CLASS_DOWN_WRAP = 'minirefresh-downwrap';\n  var CLASS_UP_WRAP = 'minirefresh-upwrap';\n  var CLASS_FADE_IN = 'minirefresh-fade-in';\n  var CLASS_FADE_OUT = 'minirefresh-fade-out';\n  var CLASS_TO_TOP = 'minirefresh-totop';\n  var CLASS_ROTATE = 'minirefresh-rotate';\n  var CLASS_HARDWARE_SPEEDUP = 'minirefresh-hardware-speedup';\n  var CLASS_HIDDEN = 'minirefresh-hidden';\n  var CLASS_BODY_SCROLL_WRAP = 'body-scroll-wrap';\n  /**\n   * 本主题的特色样式\n   */\n\n  var CLASS_DOWN_SUCCESS = 'downwrap-success';\n  var CLASS_DOWN_ERROR = 'downwrap-error';\n  var CLASS_STATUS_DEFAULT = 'status-default';\n  var CLASS_STATUS_PULL = 'status-pull';\n  var CLASS_STATUS_LOADING = 'status-loading';\n  var CLASS_STATUS_SUCCESS = 'status-success';\n  var CLASS_STATUS_ERROR = 'status-error';\n  var CLASS_STATUS_NOMORE = 'status-nomore';\n  /**\n   * 一些常量\n   */\n\n  var DEFAULT_DOWN_HEIGHT = 75;\n  var defaultSetting$1 = {\n    down: {\n      successAnim: {\n        // 下拉刷新结束后是否有成功动画，默认为false，如果想要有成功刷新xxx条数据这种操作，请设为true，并实现对应hook函数\n        isEnable: false,\n        duration: 300\n      },\n      // 可选，在下拉可刷新状态时，下拉刷新控件上显示的标题内容\n      contentdown: '下拉刷新',\n      // 可选，在释放可刷新状态时，下拉刷新控件上显示的标题内容\n      contentover: '释放刷新',\n      // 可选，正在刷新状态时，下拉刷新控件上显示的标题内容\n      contentrefresh: '加载中...',\n      // 可选，刷新成功的提示，当开启successAnim时才有效\n      contentsuccess: '刷新成功',\n      // 可选，刷新失败的提示，错误回调用到，当开启successAnim时才有效\n      contenterror: '刷新失败',\n      // 是否默认跟随进行css动画\n      isWrapCssTranslate: false\n    },\n    up: {\n      toTop: {\n        // 是否开启点击回到顶部\n        isEnable: true,\n        duration: 300,\n        // 滚动多少距离才显示toTop\n        offset: 800\n      },\n      // 默认为空，可以自行改为 上拉显示更多 等\n      contentdown: '',\n      contentrefresh: '加载中...',\n      contentnomore: '没有更多数据了'\n    }\n  };\n\n  var MiniRefreshTheme = function (_Core) {\n    _inherits(MiniRefreshTheme, _Core);\n    /**\n     * 构造，使用新的默认参数\n     * @param {Object} options 配置信息\n     * @constructor\n     */\n\n\n    function MiniRefreshTheme(options) {\n      _classCallCheck$2(this, MiniRefreshTheme);\n\n      var newOptions = extend$1(true, {}, defaultSetting$1, options);\n      return _possibleConstructorReturn(this, (MiniRefreshTheme.__proto__ || Object.getPrototypeOf(MiniRefreshTheme)).call(this, newOptions));\n    }\n\n    _createClass$2(MiniRefreshTheme, [{\n      key: '_initHook',\n      value: function _initHook() {\n        var container = this.container;\n        var contentWrap = this.contentWrap;\n        container.classList.add(CLASS_THEME); // 加上硬件加速让动画更流畅\n\n        contentWrap.classList.add(CLASS_HARDWARE_SPEEDUP);\n\n        if (this.options.isUseBodyScroll) {\n          // 如果使用了body的scroll，需要增加对应的样式，否则默认的absolute无法被监听到\n          container.classList.add(CLASS_BODY_SCROLL_WRAP);\n          contentWrap.classList.add(CLASS_BODY_SCROLL_WRAP);\n        }\n\n        this._initDownWrap();\n\n        this._initUpWrap();\n\n        this._initToTop();\n      }\n      /**\n       * 刷新的实现，需要根据新配置进行一些更改\n       */\n\n    }, {\n      key: '_refreshHook',\n      value: function _refreshHook() {\n        // 如果开关csstranslate，需要兼容\n        if (this.options.down.isWrapCssTranslate) {\n          this._transformDownWrap(-this.downWrapHeight);\n        } else {\n          this._transformDownWrap(0, 0, true);\n        } // toTop的显影控制，如果本身显示了，又更新为隐藏，需要马上隐藏\n\n\n        if (!this.options.up.toTop.isEnable) {\n          this.toTopBtn && this.toTopBtn.classList.add(CLASS_HIDDEN);\n          this.isShowToTopBtn = false;\n        }\n      }\n    }, {\n      key: '_initDownWrap',\n      value: function _initDownWrap() {\n        var container = this.container;\n        var contentWrap = this.contentWrap;\n        var options = this.options; // 下拉的区域\n\n        var downWrap = document.createElement('div');\n        downWrap.className = CLASS_DOWN_WRAP + ' ' + CLASS_HARDWARE_SPEEDUP;\n        downWrap.innerHTML = ' \\n            <div class=\"downwrap-content\">\\n                <p class=\"downwrap-progress\"></p>\\n                <p class=\"downwrap-tips\">' + options.down.contentdown + '</p>\\n            </div>\\n        ';\n        container.insertBefore(downWrap, contentWrap);\n        this.downWrap = downWrap;\n        this.downWrapProgress = this.downWrap.querySelector('.downwrap-progress');\n        this.downWrapTips = this.downWrap.querySelector('.downwrap-tips'); // 是否能下拉的变量，控制pull时的状态转变\n\n        this.isCanPullDown = false;\n        this.downWrapHeight = downWrap.offsetHeight || DEFAULT_DOWN_HEIGHT;\n\n        this._transformDownWrap(-this.downWrapHeight);\n\n        MiniRefreshTheme._changeWrapStatusClass(this.downWrap, CLASS_STATUS_DEFAULT);\n      }\n    }, {\n      key: '_transformDownWrap',\n      value: function _transformDownWrap() {\n        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var isForce = arguments[2];\n\n        if (!isForce && !this.options.down.isWrapCssTranslate) {\n          // 哪怕关闭了isWrapCssTranslate，也可以通过isForce参数强制移动\n          return;\n        }\n\n        var duratuinStr = duration + 'ms';\n        var transformStr = 'translateY(' + offset + 'px)  translateZ(0px)'; // 记得动画时 translateZ 否则硬件加速会被覆盖\n\n        this.downWrap.style.webkitTransitionDuration = duratuinStr;\n        this.downWrap.style.transitionDuration = duratuinStr;\n        this.downWrap.style.webkitTransform = transformStr;\n        this.downWrap.style.transform = transformStr;\n      }\n    }, {\n      key: '_initUpWrap',\n      value: function _initUpWrap() {\n        var contentWrap = this.contentWrap;\n        var options = this.options; // 上拉区域\n\n        var upWrap = document.createElement('div');\n        upWrap.className = CLASS_UP_WRAP + ' ' + CLASS_HARDWARE_SPEEDUP;\n        upWrap.innerHTML = ' \\n            <p class=\"upwrap-progress\"></p>\\n            <p class=\"upwrap-tips\">' + options.up.contentdown + '</p>\\n        ';\n        upWrap.style.visibility = 'hidden'; // 加到container中\n\n        contentWrap.appendChild(upWrap);\n        this.upWrap = upWrap;\n        this.upWrapProgress = this.upWrap.querySelector('.upwrap-progress');\n        this.upWrapTips = this.upWrap.querySelector('.upwrap-tips');\n\n        MiniRefreshTheme._changeWrapStatusClass(this.upWrap, CLASS_STATUS_DEFAULT);\n      }\n      /**\n       * 自定义实现一个toTop，由于这个是属于额外的事件所以没有添加的核心中，而是由各自的主题决定是否实现或者实现成什么样子\n       * 不过框架中仍然提供了一个默认的minirefresh-totop样式，可以方便使用\n       */\n\n    }, {\n      key: '_initToTop',\n      value: function _initToTop() {\n        var _this2 = this;\n\n        var options = this.options;\n        var toTop = options.up.toTop.isEnable;\n        var duration = options.up.toTop.duration;\n\n        if (toTop) {\n          var toTopBtn = document.createElement('div');\n          toTopBtn.className = CLASS_TO_TOP + ' ' + CLASS_THEME;\n\n          toTopBtn.onclick = function () {\n            _this2.scroller.scrollTo(0, duration);\n          };\n\n          toTopBtn.classList.add(CLASS_HIDDEN);\n          this.toTopBtn = toTopBtn;\n          this.isShowToTopBtn = false; // 默认添加到body中防止冲突\n          // 需要添加到container，否则多个totop无法识别\n\n          this.container.appendChild(toTopBtn);\n        }\n      }\n    }, {\n      key: '_pullHook',\n      value: function _pullHook(downHight, downOffset) {\n        var options = this.options;\n        var FULL_DEGREE = 360;\n\n        if (downHight < downOffset) {\n          if (this.isCanPullDown) {\n            this.isCanPullDown = false;\n\n            MiniRefreshTheme._changeWrapStatusClass(this.downWrap, CLASS_STATUS_DEFAULT);\n\n            this.downWrapTips.innerText = options.down.contentdown;\n          }\n        } else if (!this.isCanPullDown) {\n          this.downWrapTips.innerText = options.down.contentover;\n          this.isCanPullDown = true;\n\n          MiniRefreshTheme._changeWrapStatusClass(this.downWrap, CLASS_STATUS_PULL);\n        }\n\n        if (this.downWrapProgress) {\n          var rate = downHight / downOffset;\n          var progress = FULL_DEGREE * rate;\n          var rotateStr = 'rotate(' + progress + 'deg)';\n          this.downWrapProgress.style.webkitTransform = rotateStr;\n          this.downWrapProgress.style.transform = rotateStr;\n        }\n\n        this._transformDownWrap(-this.downWrapHeight + downHight);\n      }\n    }, {\n      key: '_scrollHook',\n      value: function _scrollHook(scrollTop) {\n        // 用来判断toTop\n        var options = this.options;\n        var toTop = options.up.toTop.isEnable;\n        var toTopBtn = this.toTopBtn;\n\n        if (toTop && toTopBtn) {\n          if (scrollTop >= options.up.toTop.offset) {\n            if (!this.isShowToTopBtn) {\n              toTopBtn.classList.remove(CLASS_FADE_OUT);\n              toTopBtn.classList.remove(CLASS_HIDDEN);\n              toTopBtn.classList.add(CLASS_FADE_IN);\n              this.isShowToTopBtn = true;\n            }\n          } else if (this.isShowToTopBtn) {\n            toTopBtn.classList.add(CLASS_FADE_OUT);\n            toTopBtn.classList.remove(CLASS_FADE_IN);\n            this.isShowToTopBtn = false;\n          }\n        }\n      }\n    }, {\n      key: '_downLoaingHook',\n      value: function _downLoaingHook() {\n        // 默认和contentWrap的同步\n        this._transformDownWrap(-this.downWrapHeight + this.options.down.offset, this.options.down.bounceTime);\n\n        this.downWrapTips.innerText = this.options.down.contentrefresh;\n        this.downWrapProgress.classList.add(CLASS_ROTATE);\n\n        MiniRefreshTheme._changeWrapStatusClass(this.downWrap, CLASS_STATUS_LOADING);\n      }\n    }, {\n      key: '_downLoaingSuccessHook',\n      value: function _downLoaingSuccessHook(isSuccess, successTips) {\n        this.options.down.contentsuccess = successTips || this.options.down.contentsuccess;\n        this.downWrapTips.innerText = isSuccess ? this.options.down.contentsuccess : this.options.down.contenterror;\n        this.downWrapProgress.classList.remove(CLASS_ROTATE);\n        this.downWrapProgress.classList.add(CLASS_FADE_OUT);\n        this.downWrapProgress.classList.add(isSuccess ? CLASS_DOWN_SUCCESS : CLASS_DOWN_ERROR);\n\n        MiniRefreshTheme._changeWrapStatusClass(this.downWrap, isSuccess ? CLASS_STATUS_SUCCESS : CLASS_STATUS_ERROR);\n      }\n    }, {\n      key: '_downLoaingEndHook',\n      value: function _downLoaingEndHook(isSuccess) {\n        this.downWrapTips.innerText = this.options.down.contentdown;\n        this.downWrapProgress.classList.remove(CLASS_ROTATE);\n        this.downWrapProgress.classList.remove(CLASS_FADE_OUT);\n        this.downWrapProgress.classList.remove(isSuccess ? CLASS_DOWN_SUCCESS : CLASS_DOWN_ERROR); // 默认为不可见\n        // 需要重置回来\n\n        this.isCanPullDown = false;\n\n        this._transformDownWrap(-this.downWrapHeight, this.options.down.bounceTime);\n\n        MiniRefreshTheme._changeWrapStatusClass(this.downWrap, CLASS_STATUS_DEFAULT);\n      }\n    }, {\n      key: '_cancelLoaingHook',\n      value: function _cancelLoaingHook() {\n        this._transformDownWrap(-this.downWrapHeight, this.options.down.bounceTime);\n\n        MiniRefreshTheme._changeWrapStatusClass(this.downWrap, CLASS_STATUS_DEFAULT);\n      }\n    }, {\n      key: '_upLoaingHook',\n      value: function _upLoaingHook(isShowUpLoading) {\n        if (isShowUpLoading) {\n          this.upWrapTips.innerText = this.options.up.contentrefresh;\n          this.upWrapProgress.classList.add(CLASS_ROTATE);\n          this.upWrapProgress.classList.remove(CLASS_HIDDEN);\n          this.upWrap.style.visibility = 'visible';\n        } else {\n          this.upWrap.style.visibility = 'hidden';\n        }\n\n        MiniRefreshTheme._changeWrapStatusClass(this.upWrap, CLASS_STATUS_LOADING);\n      }\n    }, {\n      key: '_upLoaingEndHook',\n      value: function _upLoaingEndHook(isFinishUp) {\n        if (!isFinishUp) {\n          // 接下来还可以加载更多\n          // this.upWrap.style.visibility = 'hidden';\n          this.upWrapTips.innerText = this.options.up.contentdown;\n\n          MiniRefreshTheme._changeWrapStatusClass(this.upWrap, CLASS_STATUS_DEFAULT);\n        } else {\n          // 已经没有更多数据了\n          // this.upWrap.style.visibility = 'visible';\n          this.upWrapTips.innerText = this.options.up.contentnomore;\n\n          MiniRefreshTheme._changeWrapStatusClass(this.upWrap, CLASS_STATUS_NOMORE);\n        }\n\n        this.upWrapProgress.classList.remove(CLASS_ROTATE);\n        this.upWrapProgress.classList.add(CLASS_HIDDEN);\n      }\n    }, {\n      key: '_resetUpLoadingHook',\n      value: function _resetUpLoadingHook() {\n        // this.upWrap.style.visibility = 'hidden';\n        this.upWrapTips.innerText = this.options.up.contentdown;\n        this.upWrapProgress.classList.remove(CLASS_ROTATE);\n        this.upWrapProgress.classList.add(CLASS_HIDDEN);\n\n        MiniRefreshTheme._changeWrapStatusClass(this.upWrap, CLASS_STATUS_DEFAULT);\n      }\n    }, {\n      key: '_lockUpLoadingHook',\n      value: function _lockUpLoadingHook(isLock) {\n        this.upWrap.style.visibility = isLock ? 'hidden' : 'visible';\n      }\n    }, {\n      key: '_lockDownLoadingHook',\n      value: function _lockDownLoadingHook(isLock) {\n        this.downWrap.style.visibility = isLock ? 'hidden' : 'visible';\n      }\n    }], [{\n      key: '_changeWrapStatusClass',\n      value: function _changeWrapStatusClass(wrap, statusClass) {\n        wrap.classList.remove(CLASS_STATUS_NOMORE);\n        wrap.classList.remove(CLASS_STATUS_DEFAULT);\n        wrap.classList.remove(CLASS_STATUS_PULL);\n        wrap.classList.remove(CLASS_STATUS_LOADING);\n        wrap.classList.remove(CLASS_STATUS_SUCCESS);\n        wrap.classList.remove(CLASS_STATUS_ERROR);\n        wrap.classList.add(statusClass);\n      }\n    }]);\n\n    return MiniRefreshTheme;\n  }(Core$2);\n\n  MiniRefreshTheme.sign = 'default';\n  MiniRefreshTheme.version = version;\n  namespace$1('theme.defaults', MiniRefreshTheme); // 覆盖全局变量\n\n  window.MiniRefresh = MiniRefreshTheme;\n  /**\n   * 默认暴露的是MiniRefreshTools变量，各大主题都是挂在到上面的\n   */\n\n  return MiniRefreshTools$2;\n});","map":null,"metadata":{},"sourceType":"script"}